<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fantasy Hex Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    #map { position: fixed; inset: 0; width: 100vw; height: 100vh; height: 100svh; height: 100dvh; background: #000; }
    #coords {
      position: absolute; left: 12px; bottom: 12px; z-index: 1000;
      background: rgba(0,0,0,.6); color:#fff; padding:6px 8px; border-radius:8px;
      font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    #bar {
      position: absolute; top: 10px; right: 10px; z-index: 1000;
      background: rgba(255,255,255,.95); padding: 8px 10px; border-radius: 10px;
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; display:flex; gap:8px; align-items:center;
      box-shadow: 0 6px 24px rgba(0,0,0,.15);
    }
    button { font: inherit; }
  </style>
</head>
<body>
  <div id="bar">
    <span id="status">Loading…</span>
    <button id="login"  style="display:none">Login with Discord</button>
    <button id="logout" style="display:none">Logout</button>
    <button id="secret" style="display:none">Show secret map</button>
    <button id="back"   style="display:none">Back to public</button>
  </div>

  <div id="map"></div>
  <div id="coords">X: –, Y: –</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ====================== YOUR HEX CONFIG (kept) ======================
    const HEX = { orientation: 'pointy', size: 65, origin: { x: 226, y: 6045 } };
    const COVER = { allowExtraZoomOutLevels: 0 };
    const LABEL = { xOffset: -1, yOffset: 1, yScale: -1, xIndexMethod: 'round' };
    // ===================================================================

    // Small helpers for auth/UI
    const $ = (id) => document.getElementById(id);
    const statusEl = $('status'), loginBtn = $('login'), logoutBtn = $('logout'),
          secretBtn = $('secret'), backBtn = $('back');

    // Fetch a short-lived image URL for a map ('public' or 'secret')
    async function getImageSrc(mapKey='public') {
      const r = await fetch(`/img-meta?map=${mapKey}`);
      if (!r.ok) throw new Error(`img-meta failed (${mapKey})`);
      const j = await r.json();
      if (!j.ok) throw new Error(j.error || 'img-meta error');
      return j.src; // e.g., /img/public?expires=...&sig=...
    }

    // Build or rebuild the map for a given image URL
    let map; // Leaflet instance
    async function buildMapFor(srcUrl) {
      // (Re)load image to get dimensions
      const img = await new Promise((resolve, reject) => {
        const i = new Image();
        i.onload = () => resolve(i);
        i.onerror = () => reject(new Error('Image load error: ' + srcUrl));
        i.src = srcUrl;
      });

      const imgW = img.naturalWidth, imgH = img.naturalHeight;

      // If a map exists already, destroy it fully (simplest/cleanest)
      if (map) { map.remove(); }

      // ---------- Bounds & map ----------
      const bounds = L.latLngBounds([[0, 0], [imgH, imgW]]);
      map = L.map('map', {
        crs: L.CRS.Simple,
        zoomSnap: 0, zoomDelta: 0.25,
        maxBounds: bounds, maxBoundsViscosity: 1.0,
        wheelPxPerZoomLevel: 80
      });

      // Base image
      const base = L.imageOverlay(srcUrl, bounds).addTo(map);

      // Cover canvas (no gaps)
      const applyCover = () => {
        const coverZoom = map.getBoundsZoom(bounds, { inside: false });
        const minZ = coverZoom - (COVER.allowExtraZoomOutLevels || 0);
        map.setMinZoom(minZ);
        if (map.getZoom() < minZ) map.setZoom(minZ, { animate: false });
        map.setView(bounds.getCenter(), Math.max(map.getZoom(), minZ), { animate: false });
        map.panInsideBounds(bounds, { animate: false });
      };
      applyCover();
      addEventListener('resize', applyCover);
      addEventListener('orientationchange', applyCover);

      // ---------- HEX MATH (POINTY-TOP) ----------
      const SQRT3 = Math.sqrt(3);
      function axialToPixel(q, r) {
        const x = HEX.size * SQRT3 * (q + r/2) + HEX.origin.x;
        const y = HEX.size * 1.5   * r + HEX.origin.y;
        return { x, y };
      }
      function pixelToAxial(x, y) {
        const px = x - HEX.origin.x, py = y - HEX.origin.y;
        const q  = (SQRT3/3 * px - 1/3 * py) / HEX.size;
        const r  = (2/3 * py) / HEX.size;
        return { q, r };
      }
      function axialToCube(q, r){ return { x:q, y:-q-r, z:r }; }
      function cubeToAxial(x,y,z){ return { q:x, r:z }; }
      function cubeRound(x, y, z) {
        let rx = Math.round(x), ry = Math.round(y), rz = Math.round(z);
        const dx = Math.abs(rx-x), dy = Math.abs(ry-y), dz = Math.abs(rz-z);
        if (dx > dy && dx > dz) rx = -ry - rz;
        else if (dy > dz)       ry = -rx - rz;
        else                    rz = -rx - ry;
        return { x: rx, y: ry, z: rz };
      }
      function axialRound(q, r) {
        const c = cubeRound(q, -q - r, r);
        return cubeToAxial(c.x, c.y, c.z);
      }
      function hexCornersFor(q, r) {
        const c = axialToPixel(q, r);
        const corners = [];
        for (let i = 0; i < 6; i++) {
          const angleDeg = 60 * i - 30;
          const ang = Math.PI/180 * angleDeg;
          corners.push({ x: c.x + HEX.size * Math.cos(ang), y: c.y + HEX.size * Math.sin(ang) });
        }
        return corners;
      }

      // ---------- LABELS ----------
      function numberToLetters(n) {
        let s = ""; while (n > 0) { const r = (n - 1) % 26; s = String.fromCharCode(65 + r) + s; n = Math.floor((n - 1) / 26); }
        return s || "0";
      }
      function screenColumnIndex(q, r) { return Math.round(q + r/2); }
      function finalCoordLabel(q, r) {
        const col = screenColumnIndex(q, r) + (LABEL.xOffset || 0);
        const rowLabel = (LABEL.yScale || 1) * r + (LABEL.yOffset || 0);
        const isOddY = Math.abs(Math.round(rowLabel)) % 2 === 1;
        const col1 = col + 1;
        const mappedX1 = isOddY ? (2 * col1 + 1) : (2 * col1);
        const X = numberToLetters(mappedX1);
        const Y = String(Math.round(rowLabel));
        return { X, Y };
      }

      // ---------- UI: hover + click ----------
      const hoverHex = L.polygon([], { weight: 1, color: '#00A', fillOpacity: 0.08 }).addTo(map);
      const tip = L.tooltip({ opacity: 0.9, direction: 'top' });
      let lastClick = null;

      map.on('mousemove', (e) => {
        const px = e.latlng.lng, py = e.latlng.lat;
        const { q, r } = axialRound(...Object.values(pixelToAxial(px, py)));
        const corners = hexCornersFor(q, r).map(p => [p.y, p.x]);
        hoverHex.setLatLngs(corners);
        const center = axialToPixel(q, r);
        const { X, Y } = finalCoordLabel(q, r);
        tip.setLatLng([center.y, center.x]).setContent(`${X}${Y}`).addTo(map);
        $('coords').textContent = `X: ${px.toFixed(1)}  Y: ${py.toFixed(1)}  |  q=${q} r=${r}  |  ${X}${Y}`;
      });

      map.on('click', (e) => {
        const px = e.latlng.lng, py = e.latlng.lat;
        const { q, r } = axialRound(...Object.values(pixelToAxial(px, py)));
        const c = axialToPixel(q, r);
        const { X, Y } = finalCoordLabel(q, r);
        lastClick = { lat: c.y, lng: c.x };
        L.marker([c.y, c.x]).addTo(map).bindPopup(`Hex: <b>${X}${Y}</b><br>(q=${q}, r=${r})`).openPopup();
      });

      // Console helpers
      window.hex = {
        map,
        setOriginFromHere() { if (!lastClick) return console.warn('Click first'); HEX.origin = { x: lastClick.lng, y: lastClick.lat }; console.log('Origin', HEX.origin); },
        setOrigin(x, y) { HEX.origin = { x, y }; console.log('Origin', HEX.origin); },
        setSize(s) { HEX.size = s; console.log('Size', s); },
        setYScale(k) { LABEL.yScale = k; console.log('yScale', k); },
        setOffsets(xOff=0, yOff=0) { LABEL.xOffset = xOff; LABEL.yOffset = yOff; console.log('Offsets:', xOff, yOff); },
      };
    }

    // ---- Boot flow: public first (no login), then optionally secret ----
    async function boot() {
      // Public map (no auth)
      const publicSrc = await getImageSrc('public');
      await buildMapFor(publicSrc);
      statusEl.textContent = 'Public map (no login required)';

      // Session status
      const meRes = await fetch('/api/me');
      const me = meRes.ok ? await meRes.json() : { ok:false };

      if (!me.ok) {
        loginBtn.style.display = 'inline-block';
        loginBtn.onclick = () => location.href = '/login';
      } else {
        logoutBtn.style.display = 'inline-block';
        logoutBtn.onclick = () => location.href = '/logout';
        if (me.isPriv) {
          secretBtn.style.display = 'inline-block';
          secretBtn.onclick = async () => {
            try {
              const secretSrc = await getImageSrc('secret');
              await buildMapFor(secretSrc);
              statusEl.textContent = `Secret map (hello ${me.user.username})`;
              secretBtn.style.display = 'none';
              backBtn.style.display = 'inline-block';
            } catch {
              alert('You need the required role to see the secret map.');
            }
          };
          backBtn.onclick = async () => {
            const publicSrc2 = await getImageSrc('public');
            await buildMapFor(publicSrc2);
            statusEl.textContent = 'Public map (no login required)';
            backBtn.style.display = 'none';
            secretBtn.style.display = 'inline-block';
          };
        }
      }
    }

    boot().catch(err => {
      console.error(err);
      statusEl.textContent = 'Init error.';
    });
  </script>
</body>
</html>